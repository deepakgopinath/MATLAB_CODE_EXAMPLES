function [ sigFeature, idxFeature, cFeature,wFeature ] = importanceModified( data, attributeVec, k )

%importanceModified takes into account examples with missing features
numAttributes = length(attributeVec);
d = size(data, 2) - 1;
p = length(find(data(:, d+1) == 1)); %number of positive samples
n = length(find(data(:, d+1) == 0)); %number of negative samples.
mult = [-1*ones(n,1); ones(p,1)]; %assumes that all the 0 labels are at the top of data list and all the 1's are the latter 'half'
totalEntropy = booleanEntropy(p/(p+n));

%variables to store necessary values.
remainderAttr = zeros(numAttributes, 1); % this will be populated by the info gain for each attribute
gainAttr = zeros(numAttributes,1);
pnForEachk = zeros(2, k, numAttributes); % first row represnts p for each k and second row is n for eack k;
idxI = zeros(n+p, numAttributes); %indices from kmeans. 
cI = zeros(k, numAttributes); %centroid learned from kmeans
weights = ones(k, numAttributes); %weights for each node. 

for i=1:numAttributes
    colData = data(:, attributeVec(i));
    if(sum(isnan(colData)) == 0)
       [idx, c] = kmeans(colData, k, 'EmptyAction', 'singleton'); % do kmeans because kmeans ignoes NaN. 
       tabIdx = tabulate(idx);
    end
    if(sum(isnan(colData)) > 0) % if there are missing features in this attribute
        if(length(colData) - sum(isnan(colData)) <= k) %if the number of samples with elements not equal NaN is less than k, we will have troubles running kmeans, so skip it and continue.
          continue;   
        end
       [idx, c] = kmeans(colData, k, 'EmptyAction', 'singleton'); % do kmeans because kmeans ignoes NaN. 
       tabIdx = tabulate(idx);
       nanIdx = find(isnan(colData) == 1); % to be used for replacing the NAn with individual vector values. 
       replaceIdx = min(find(tabIdx(:,2) == max(tabIdx(:,2)))); %replace all the NaN's with the max occuring label.
       idx(nanIdx) = replaceIdx;
    end
    idxI(:,i) = idx;
    cI(:,i) = c;
    weights(:, i) = tabIdx(:, 3)/100;
    idx = idx.*mult;
    for j=1:k %calculate remainder for each possible value of an attribute
        pnForEachk(1, j, i) = length(find(idx == j));
        pnForEachk(2, j, i) = length(find(idx == -j));
        pk = pnForEachk(1, j, i);
        nk = pnForEachk(2, j, i);
        remainderAttr(i) = remainderAttr(i) + ((pk + nk)/(p+n))*booleanEntropy(pk/(pk+nk));
    end 
end
gainAttr = totalEntropy - remainderAttr;
sigFeature = attributeVec(min(find(gainAttr == max(gainAttr)))); %return that feature, centroid, weights, and labels generated by the attribute which has the best gain
idxFeature = idxI(:,min(find(gainAttr == max(gainAttr))));
cFeature = cI(:, min(find(gainAttr == max(gainAttr))));
wFeature = weights(:, min(find(gainAttr == max(gainAttr))));
end

